# -*- coding: utf-8 -*-
"""processamento_de_linguagem_natural.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RKCFk3-45ufMonOaswI9Pml3ER5GEUkm
"""

#dataset do kaggle: https://www.kaggle.com/datasets/sid321axn/amazon-alexa-reviews

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

#Carregar a base de dados
reviews_df = pd.read_csv('/content/amazon_alexa.tsv', sep = '\t')

#Tamanho -> (quantidade de linhas, quantidade de colunas)
reviews_df.shape

#Visão geral do dataset
reviews_df

#Informações sobre os tipos de dados
reviews_df.info()

#Estatística gerada para os atributos numéricos
reviews_df.describe()

#Coluna dos textos
reviews_df['verified_reviews']

#Exploração dos dados com o método .headmap da biblioteca seaborn
sns.heatmap(reviews_df.isnull(), cbar=False)

#Visualizar para ter certeza que não tem nenhum valor nulo
reviews_df.isnull().sum()

#Criar histogramas para visualizar
reviews_df.hist(bins = 30, figsize=(13,5), color = 'r')

#Percorrer todos os textos para verificar o tamanho da string
reviews_df['verified_reviews'] = reviews_df['verified_reviews'].astype(str)
reviews_df['length'] = reviews_df['verified_reviews'].apply(len)
reviews_df.head()

#Histograma do tamanho dos comentários
reviews_df['length'].plot(bins = 100, kind = 'hist');

#Mais informações sobre a frequência de comentários
reviews_df.length.describe()

#Ver o maior review
reviews_df[reviews_df['length'] == 2851]['verified_reviews'].iloc[0]

#Ver o menor review
reviews_df[reviews_df['length'] == 1]['verified_reviews'].iloc[0]

#Ver a média dos reviews
reviews_df[reviews_df['length'] == 131]['verified_reviews'].iloc[0]

#Reviews somente positivos
positive = reviews_df[reviews_df['feedback'] == 1]

#Visualização dessa tabela gerada
positive

#Mais dados sobre essa tabela
positive.describe()

#O mesmo processo para os reviews negativos, a média de escrita é maior para quem vai falar mal
negative = reviews_df[reviews_df['feedback'] == 0]
#negative
#negative.describe()

#Gráfico do feedback
#Esse comando aqui não ficou bom -> sns.countplot(reviews_df['feedback']);
sns.countplot(x='feedback', data=reviews_df)
plt.show()

#Gráfico de rating
sns.countplot(x = 'rating', data = reviews_df);

#Gráfico das cores escolhidas do produto
plt.figure(figsize = (40,15))
#Esse aqui não ficou legal -> sns.barplot(x = 'variation', y = 'rating', data = reviews_df, palette = 'deep');
sns.barplot(x='variation', y='rating', hue='variation', data=reviews_df, palette='deep', dodge=False)
plt.legend([],[], frameon=False)
plt.show()

#Fazer uma lista de todas as palavras
sentences = reviews_df['verified_reviews'].tolist()

#Verificar a quantidade de respostas (reviews)
len(sentences)

#Verificar as 10 primeiras sentenças
print(sentences[0:10])

#Agrupar em somente uma string todos os reviews
sentences_as_one_string = ' '.join(sentences)

#Amostra gerada
sentences_as_one_string

#Quantidade total de caracteres, necessário para depois sabermos quais termos são mais frequentes
len(sentences_as_one_string)

#Criar nuvem de palavras
from wordcloud import WordCloud
plt.figure(figsize=(20,20))
plt.imshow(WordCloud().generate(sentences_as_one_string));

#Agora fazendo e mesmo mas somente para a nuvem de palavras considerando os reviews negativos
negative_list = negative['verified_reviews'].tolist()
negative_sentences_as_one_string = ' '.join(negative_list)
#len(negative_sentences_as_one_string)
plt.figure(figsize=(20,20))
plt.imshow(WordCloud().generate(negative_sentences_as_one_string));

reviews_df.head()

#Pontuações
import string
string.punctuation

#Teste para remover pontuações
test = 'Sometimes, while playing a game, you can answer a question correctly but Alexa says you got it wrong and answers the same as you.  I like being able to turn lights on and off while away from home.'

#Nova variável sem pontuações
test_punc_removed = [char for char in test if char not in string.punctuation]

#Print dessa nova variável, cada caractere separado
print(test_punc_removed)

#Juntar a variável com espaço entre os caracteres
test_punc_removed = ' '.join(test_punc_removed)

test_punc_removed

#Assim fica sem espaço entre os caracteres de uma palavra
test = 'Sometimes, while playing a game, you can answer a question correctly but Alexa says you got it wrong and answers the same as you.  I like being able to turn lights on and off while away from home.'
test_punc_removed = ''.join(char for char in test if char not in string.punctuation)

words = test_punc_removed.split()
cleaned_words = [''.join(word.split()) for word in words]
final_string = ' '.join(cleaned_words)

test_punc_removed

#Selecionar stop words, palavras que não representam significância para definir emoções e sentimentos
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
print(stopwords.words('english'))

#Quantidade de palavras stop words em inglês
len(stopwords.words('english'))

#Quantidade de palavras stop words em português
len(stopwords.words('portuguese'))

test_punc_removed

print(test_punc_removed.split())

test_punc_stop_removed = [word for word in test_punc_removed.split() if word.lower() not in stopwords.words('english')]

test_punc_stop_removed

"""Tokenização (Count Vectorizer)
- Transformar letras em números;
- Cria uma lista de colunas únicas de palavras contando suas frequÇencia na frase;
- Isso gera uma matriz que então é usada na aprendizagem de máquina;
"""

#Tokenização - Teste
from sklearn.feature_extraction.text import CountVectorizer
sample_data = ['This is the first document.', 'This document is the second documment.', 'And this is the third one.', 'Is this the first document?']
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(sample_data)

#Palavras selecionadas
print(vectorizer.get_feature_names_out())

#Matriz gerada
print(X.toarray())

#Função para limpar o review
def message_cleaning(message):
  text = [char for char in message if char not in string.punctuation]
  text = ''.join(text)
  text = [word for word in text.split() if word.lower() not in stopwords.words('english')]
  return text

reviews_df_clean = reviews_df['verified_reviews'].apply(message_cleaning)

print(reviews_df_clean[3])

print(reviews_df['verified_reviews'][3])

reviews_df_clean

#Transforma textos em números com vectorizer
from sklearn.feature_extraction.text import CountVectorizer
#Remoção de pontos e de stop words
vectorizer = CountVectorizer(analyzer=message_cleaning)
reviews_countvectorizer = vectorizer.fit_transform(reviews_df['verified_reviews'])

#Seleção dos textos únicos
print(vectorizer.get_feature_names_out())

#Quantidade de palavras, igual ao número de colunas da matrix gerada
len(vectorizer.get_feature_names_out())

#Mostrar a matrix gerada
print(reviews_countvectorizer.toarray())

reviews_df.drop(['verified_reviews'], axis = 1, inplace=True)

# (Reviews, Colunas)
reviews_countvectorizer.shape

#Data frame utilizado para o treinamento
reviews_df

reviews_df = reviews_df.drop(['date', 'rating', 'length'], axis = 1)

reviews_df['variation'].unique()

X_cat = reviews_df[['variation']]
X_cat

#Para futuramente gerar dados que serão arquivados
from sklearn.preprocessing import OneHotEncoder
onehotencoder = OneHotEncoder()
X_cat = onehotencoder.fit_transform(X_cat).toarray()
X_cat = pd.DataFrame(X_cat)
reviews_df.drop(['variation'], axis = 1, inplace = True)
reviews_df = pd.concat([reviews_df, X_cat], axis = 1)



reviews_df

type(reviews_countvectorizer)

reviews = pd.DataFrame(reviews_countvectorizer.toarray())
type(reviews)

reviews_df = pd.concat([reviews_df, reviews], axis = 1)

reviews_df

#Variável X que terá os atributos previsores
X = reviews_df.drop(['feedback'], axis = 1)
X

#Variável Y que terá as classes
Y = reviews_df['feedback']
Y

"""Intuição sobre o algoritmo Naïve Bayes:
- o Naïve Bayes é um algortimo de classificação baseado no teorema de Bayes;
- lê-se neivi beis;
- eficiente para classificação de textos;
- passos:

  1. Probabilidades a priori

      Caso analisado / Total de casos

  2. Likehood
  
      Considerar a vizinhança

      Probabilidade de pertencer a uma classe dependendo da sua zinhança

  3. Probabilidade porteriori

      Probabilidade priori * likehood

      Compara essas probabilidades, a maior vence

"""

#Seleção para treinamento, com 20% dos dados para testes
from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size = 0.2)

#Verificação do tamanho da amostra de dados para treino e testes
X_train.shape, X_test.shape

#Para estudar mais sobre algoritmos Naïve Bayes: https://iaexpert.academy/2019/04/24/tipos-de-metodos-naive-bayes/

#Um método baseado no algoritmo Naïve Bayes
from sklearn.naive_bayes import MultinomialNB
naive_bayes = MultinomialNB()
naive_bayes.fit(X_train, Y_train)

#Análise dos dados
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

Y_pred = naive_bayes.predict(X_test)

Y_pred

Y_test

#Percentual de acerto
#Considera todas as classes participantes do treinamento (reviews negativo e positivo)
accuracy_score(Y_test, Y_pred)

#Lembrando que a base de dados está desbalanceada (tem mais reviews positivos que negativos)
#Por isso o uso da matriz de confusão
cm = confusion_matrix(Y_test, Y_pred)
cm

#Coordenadas: reviews
#Abscissa: classificação realizada do review
sns.heatmap(cm, annot=True)

#Com esse print, percebe-se que a precisão de identificar reviews negativos (valor 0) e valores poritvos (valor 1)
#Com essa base de dados desbalanceada, é importante analisar a coluna f1-score
#Precision = precisão ao analisar os dados
#Recall = eficiência em identificar se um review é positivo ou negativo
print(classification_report(Y_test, Y_pred))

#Treinamento por regressão logística
from sklearn.linear_model import LogisticRegression
logistic = LogisticRegression()
logistic.fit(X_train, Y_train)

Y_pred = logistic.predict(X_test)

accuracy_score(Y_test, Y_pred)

print(classification_report(Y_test, Y_pred))

"""Com o algoritmo de regressão logística, percebe-se que a precisão de classificar os reviews como negativos possui a precisão de 79%

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAC/CAIAAAAQDR4cAAAgAElEQVR4Ae1dzaojR7I+C7+INt77SRr8AAbh3fgJvPE0g8WBxtyN1wPdmwvyMbObjblcunc2B+EX8KLvjM2Bs5it6N7oOjIz/rIy60cqSVWqTzStqvyJjPgi8svIUlWdu/+UPnt8gAAQAALLQ+CuxIf/WR4OsBgIAAEgsAchIgiAABAAAgmB8xLiv/755ddffPpmdzrcH9785ePffumQ8/7Ni7v4+eZtR9Pjqn97TQMUhL9//Xka2dS+fXl3d/f56/fHjdXeq6pJe7dZ1v7xv1999o/HWao+IaUpRF++Swo9/uOzV782lfvwt88+cpNm7SJKpkOIv//01yp1vvvu4yfffejpEKLFAmf17N3arEJDNGKB+MYgxHcvS5L3+4omrdpPuLJm5n6///XVZ9+/SnT47uXd3YvXv6khYQl82b76vf3m7sWbU1elE4U09Xz7zdkWS4XHHjlC3P/7h6++/+qHf9sGdPz+xw+f/OXDqWDlUud0fl5CHIJEnRB/+fjJkIXrjIRYsefE2VKRGopbmKKt29zqqmY+vvre5TLEI7ra0ZIjWU/N5lG8c7IQ4iPlZVrPHLPXlB+v3BNiXGle//BHY4B33338/Me+yUej9+wL+hPi7z/99cuffv/5zReffk3/vuWMOxHZr3+P5V/+9HsERVpKyX6/LwvhvlEC/f9f/0xS9vvaZjnkX3Gf6rOzAiFSZpE+dv6EdbtZTqHDH80+aCqGj4Z18r6P9VCoknX2cmvZ19vJ3NQw5oCsR/hOytQ00UGN5PdvXrx48166WPOTQu4rTRtur5PWCBdM3r/+/MXr38QRUs4JbFReECCLXr7dc/votbqZ+/2+sFk2VEIqedc7U/Z7ozPjKMqIGneGp3yXiFWrkGzA1lNysfGgalLq9e7l3TdvZWgNubhyCGgqxAStFu73xsw/IfDe/+OH126xSXr834fPh+QfJe1nXDaIED/9+ovEbkRhf/852E2EKBRmyiMoP7/hLqZxFEIdDfFVMsSye2hSaZR4/CmMspiQUxOUYddp5jALaXTnivDtMwWe2zzdChs6GTp0DyHeHPTtS2lmNdzv99XUae81CS15vlEvTkDipIpY0XErg+z3aV7F9kSLUTGjlRESGyfS1MZhEvLcM55K0zi2p3JuUzOzPGN5IC/Becmd5EBRJWnO8WPkkIZN71CHkhA3So8THtRwerUXAc7g2/axPCppyhmTzDQekYahYwU8DFxYb6i8loJUlb2limGEqD+P7L79+q///S9CIhBiIsf9XssjSgVCFCH0k4t0DHKkSiH+5WPzooaZk9pQjqhW+EVK08Hbl8wU8TJcFiIUOJTBlWdFZWLYsHPjNTQxc881tCdGwwGEmOsgE9jpUJ/wrAHJUfSYjv+cbwYo0dDPMW5MI1ra5fIMcNGQhpY2rEf4fnxVus4Vsp4XL7/xo7iO7sQNFGt+e/3CaKgQET7WUpVTEKKVvY8C/i9lmWnp5wAxOJulznDcn3FlIlb6ygENZITIuL+++gy7ZkEjHJxAiGnXXMns0jCnEmLxKq9ZD7014UzjmyupvX50GxgyqVBhpkdkvdickwgWVM4UKNSaLRO3Wmo2S7pKDEdtGnrdpKOfonm4S61Dox8hGu6Lo5Fw/4kY+kE5i3QjWrJrGd1NXTaxcuGfFy3jR+5R/BYotDblWcYmcZNUedgLQlTcgKPgaENeta4OEBNgrpw7E7D+E5V3jb2zYldCmH+wYmEE748f+v+GafrdwuEJhGgyxEJml8A5lRD3tQxRIrjhhWxC0qmun5LduG4Upn4ChGpK6DKmK00ME69Oakg2nZ7l0ds0dDHtpHtNMh301KHRQklJdmnaFJMLau8bs6o0ogFTT1tG577Own0tQ/TXB3yf5pkHKtSXh3Nds5AoCHHN+54oGu09nIYGZ1fOImrAusZGCPejX/CRIQoa4eA4QqQfTPjy31gZ4r5x/TEoWLyGGJbERiKTLHMUELfAPD/D+lzILCphSjE0KiHSpShLFlFjO3quIVlaULi5eSchwvucrOVZam3mJOQaHMflTjgXekI0i4fzjrlK0DJ62czyNUQa3xio6lSOLLzcxGjLRdl31is71cYxo3TLnlY2j6pysqaGy6iL9SwHs+lBgaoXOqTCoBriKr8agGuIApUcDCPE8Puy/oQSpFQIcfetNA4H+kOKpJP+GuJ+v5cfpoVt0yXewn0AYdalfUIKkRAWduuQwpSiP35evHkt1xBDnHGFBFzIeqTUBJkKYVFyt1aTN2uaEGAxNKMQ5nQVbjWMTjJ6xq2WNs40MS2VQ6lQpmsLJaWIIM1Zq1TUUEM43ZnpVg7jHS1vHd0orztKmrGlFGYQIUbiTj4VKEo/vxod/myuagQEjLEqhPxJ0VUgKYeenNAQfRrLzp30NpoYohSZuXpmWyMWxTsNvGcr600xBfGD3fDZMEIULrsoIgPvQ7yoboserMqe46GS34c4nuSxJAWidBQ5huQq8Y0hPMrAfrmE5RwIcb8f9KRKyUyUnQOBCxCif1LlHEacIDPlX6Ozof0l6gT12rpWfrAq/obZJufm6uZBiAu/N2rsqMs33Y3tZM8BL0KIxduzvYL2KkSyJdtp+vZTOTMXFoza4bL1mTNEPMtci4H+hFiTgHIgAASAwI0gAEK8EUfCDCAABE5HoC8h/g8+QAAIAIFbRwCEeOsehn1AAAj0RgCE2BsqNAQCQODWEQAh3rqHYR8QAAK9EQAh9oYKDYEAELh1BECIt+5h2AcEgEBvBECIvaFCQyAABG4dARDirXsY9gEBINAbARBib6jQEAgAgVtHAIR46x6GfUAACPRG4O6ADxAAAkAACAQEQIgIBCAABIBAQgCEiFAAAkAACCQEQIgIBSAABIBAQgCEiFAAAkAACCQEQIgIBSAABIBAQgCEiFAAAkAACCQEQIgIBSAABIBAQgCEiFAAAkAACCQEQIgIBSAABIBAQgCEiFAAAkAACCQEQIi3EwrPD+vVarV57GnRbrNardbb557Nb6dZMHwVjH8yVj1tCT76bHam+KjDZ5G1uj9Z2FEaoNNxCIAQj8Ntir1AiEO8stus1ltLiLEz0eKphEiOKKw0i12BhrhlxLaP5OGh6z0IcUQPQNSMEDgjIe7uV+sHPxMfN6vVZlsmyhmBNitVQYjTdtdus9rsZF8ma1dKSXgfJ+WHQ8z4mps4Uy4bZO7eyHpKjY3kbEMn6q1Wstd7flivH55393E7KSOeFWzacm4eDzyoSeWIWeLHFJIugoC9DmC2rgbYoPr5CJEG9YS424TRK5ljCUk1syGK7TfpT8n24XFV0mNomQFcE20Hta4Wj5vV/U7iUxCrxlspOA9FM23LBFffrB8Z4lCXH90+Rm10jJkzyXlxelObdBEw5BTx+pOdSCGAat51kUeKpnAp60yiHCGa0QO/xBiNIavHObOUhZ9WmuZVHJRoMepJ5jAPGnwiG8qMkqGfHza8KTaAp+oGVrG8FTGRXDkwxFRibevHioRYXNHNOMV0t6YF3BQruU5qPGtw662PGa31sBFRBXMcIcq6azxr4+2g2hoTLA7UsWTm4UB9h8cqCLHVw2NWuijX0AkelV9CJFx298yMpIP0tWHRVE6acZUXzqXpW3UIBXRqA4jjyTUjgTU6zsSfcmomtonsmDuwXGoTccs15xb221lBFQ2sYusRDLQMZVUIiblF2FXaE/Jyid+9g2IPpYxwLvp713fFlR39+GMCuRAeDmrRxBOW96au06lv7mIOzrDk60xR4SZsBtkDQhwE1ymNXViogyWCnezACLI5kjWQGnOK5NrHEzdEqqcJEz6NqZhxRHYq8erKy9oWVDmtSKeHlcM76GSQ/KSuKaRtnRJkbdxIh0tIjmDgEEIU72S/+JMa8aPLT9lMoYZou+gvBw6TSly5NiediI8MobuwVM5ymitoLt5CMrh5DGuJsqTJ/spmBhOc/L5GgRD7InVyOxcW6vWyR8uMUM1rknJuiExhilTPiapDaEqnpoGcumZlbbOhTj8tm69zyY/gNNQql2c12lSwGsFAnduqSzgSSLPyllPqwjlXw4TQL8sQ5bRsSBnYFgWOrbLgO6jViY6wVDFvZuqbQaenZTMZGRPPPQ0BIfYE6vRmJizIi5znVzxKLueZYMdu8pqpNUOY0nioMcRVVGJXXasVr8yH+NuONKtoyyLH+tbp4STSbK+ldYyndjCXF4JpzthJb5nVBnMRLV4RLpvJ6Zjh4oqnanFlhhzl0GiSxZJcDTCEaLWyYanRXgnOtqvk1KUULa32gRBb4RmzkuanfOSiYYtHQ5RwD7PWya5E9oxh2nBL+k5x4CQovVKwuo/ju1TDc8zvVirTbEycSFaFEOOFIVVdt5PxWhKrnu4+M+aHW16imXaXSh2KWJ1ye7blgghMA3DjzQJ0TkM/pQMvZGbG35RSoXOlwccMY2DJNw2m1RGH3kzRxHrtfucyxKS0Q7uqnrFdgrNl+qS1PA1RhqJpJAixicmZStrStzMNCbFAYLoImAzRKkmEaMnU1p3/GIR4fozTCCDEi0GNgeaAAAhxDl46n44gxPNhC8kzRACEOEOnQWUgAAQWhAC2zAtyNkwFAkCgHQEQYjs+qAUCQGBBCIAQF+RsmAoEgEA7AiDEdnxQCwSAwIIQACEuyNkwFQgAgXYEQIjt+KAWCACBBSEAQlyQs2EqEAAC7QiAENvxQS0QAAILQgCEuCBnw1QgAATaEQAhtuODWiAABBaEAAhxQc6GqUAACLQjAEJsxwe1QAAILAgBEOKCnA1TgQAQaEcAhNiOD2qBABBYEAIgxAU5G6YCASDQjgAIsR0f1AIBILAgBECIC3I2TAUCQKAdARBiOz6oBQJAYEEIgBAX5GyYCgSAQDsCIMR2fFALBIDAghAAIS7I2TAVCACBdgRAiO34oBYIAIEFIQBC7Ons3WaVPuuH5559ptDs+WHNim927Qo9ionc4z712N1zyXo7TeMHmMkgRKM2j3x+OBwhRDtf5GiIhhqx5DxxnPUy+/ciup9pkIqZT1uJezK/t6UgxD5+et6uV4kHA9B2FvXpf7U2FP2JB2n+y6zoVkhNpknIHUlI79jqHmSsFkeYSX8lfbNZr9SVRwgZS/+ecoZpuNuw6yvi1cWVBrMorpj5tF1z0A4yA4TYAy4TiIfDYaKkULDDRzxR+Xr7VGhXKKLGkUlpBVbW0PJCpysVHWFmNIo6smlHCLmwuUM1rDCF0Xp3z8u8KZzbYcVMEOL5HEkpEqdFac9y1OJzPg0rkncbZcC0s+D5X+nBxWaqWCG0HBiZ3PrK31alXmbykmYJcbCQixs9VMMKU6jeVqCWzu2oYiYI8XyOTIRIeWLYdU4xSypaHyOepv0qZHmG5ortudAbyPRBtXSsJMvtr/w90Ey1rkmIw7G6nO0DzaSlSz5uZ5AW9SFX1i5n5eCRKmaSl+XTdfXcDIotswGjcphnhXT5aaK/LXgLsnTJzn/f0J9ZBgw1GnObx8qC7CVc9myQmRYEezxIyGXtS6OdoCGt5Y4To0gK7HlEcj/AW8zsuJyq8kGIikX1yF9DTAljtfV0KmjCm9/E+22RaGktTJ5k1bE7kXOCMsRMlzhwBkGkMETIOY2pyz5Fw4rrNVmuDzunmhHMBCH2cXhYnNNlRDrueSWuj+iztgm5bWK3PB2I1NBIEBrpoVGwnStNwwsfHmFm0JAoRlzZJuTC9lSGa9Ow4s0oiXzacPSsfh6sIOKLK2aSl+U3AN+jcAZCLIBSKkoblngxrtRgomVhFoVUKJsSxSlU2nSohN77jstjoUr2MTPp5wjxYO9DzIRc3p7KiAPMJFfyh38SdDbexjXEHmaaTVIFVlMMQjRg4BAIAIFlIwBCXLb/YT0QAAIGARCiAQOHQAAILBsBEOKy/Q/rgQAQMAiAEA0YOAQCQGDZCIAQl+1/WA8EgIBBAIRowMAhEAACy0YAhLhs/8N6IAAEDAIgRANG+2G8k9nc49refCK1eitvn9uqo43hfl55hONgCqlmkggMMrPWmB51iJ/p35jdw5slM8NjG2xl+K4/pjmRCGY11Dukd1LbF1JFittjgxaEyHi3flNsrbfbab4etUVz8xR25cEm29k8lUjxxFNlis8vW7UPh0FmmsbRrfEd4PaYsJog7xvNu71pGlvTHHCmjSuf5Mnunsmupt4YQQtCrKFryp+26zA9JjpPjKb+kNIBfW7JhotvF8+yaaPvCps6IQ4y0zfW1zuaxeBwCEnxgHdGleAcvcxr3uFN31jNdFqpi13xRE86CZECWJaxY4MWhDjA/XMjRPvyj/Qstm6EG3a7eIoP9sbwOja2GiOcqWCQmcQUBgQ5tUJu4D24YlfEPDsNhUSpUyP9tgjpIkTvwWODFoTY5oOsbp6ESJOh1wtibdJBx7xtjMfhgpP8hZYMmauexpnQ10ybCNMxX3WyzqVjuWJwVdvM4OOYKQLnlR7yy4lTFOq+h+3JlnN/4XsA74MQGdEe33bO9Gh+9SZZVlhKE7yOkSAo6Nbb3cO6HHaTSyuGmpmok6x82NHfIkp/ZybJCRQ59/fg0ntt5J3R3szgcrv4+RiYwxl5ygcnlZjE3xkRorovJ4IQHXbtJ3MjRJoSJm78nqLd1PDXAgoRRhOpb2x1jTBW/SlmVojv2A3XWCaV5Ixp5twiOccjS2+J8lpuDBgStCDEHOuW89mFUVgbUwaUB03cCFfCqGJpSDrkunULUpetOtbMSlox1expNDOnamDfqKEfxyWvjxd8q+lhypR7By0IsY8XdDOVrmH0xreP9LO2CbMoaJ1xX4EQ1UyTV9o/327zzbNqPVj4ADNpOsWPnVTWzKmlwIrG6WYOJQgd+8pHGpzZhWxavLPYtu/6zTfXHWaAEDsAQjUQAALLQQCEuBxfw1IgAAQ6EAAhdgCEaiAABJaDAAhxOb6GpUAACHQgAELsAAjVQAAILAcBEOJyfA1LgQAQ6EAAhNgBEKqBABBYDgIgxOX4GpYCASDQgQAIsQMgVAMBILAcBECIy/E1LAUCQKADARBiB0CoBgJAYDkIgBCX42tYCgSAQAcCIMQOgFANBIDAchAAIS7H17AUCACBDgRAiB0AoRoIAIHlIABCXI6vYSkQAAIdCIAQOwBCNRAAAstBAIS4HF/DUiAABDoQACF2AIRqIAAEloMACHE5voalQAAIdCAAQuwACNVAAAgsBwEQ4nJ8DUuBABDoQACE2AEQqoEAEFgOAiDE5fgalgIBINCBAAixAyBUAwEgsBwEQIjL8TUsBQJAoAMBEGIHQKgGAtNB4PlhvUqfza5LrdbGz1uStN4+dUmZVP1T0JoQYM21hMqejbat5pt2/hCE6PHAGRCYLAKPm9Uq8eDuPp//udamMVFDkyzuNxuhlbzzJM/JIubBkoKEyT0vE8b8bqyMtIkQ4m7DC5+aRFrGdSzW2SXRtE+eppabx2QZRUCEhhaQze7A7U1YmAXEo0xQps/6gZacLJ6yUwMmDoHA+RCgCI8BSWNQYPu4dSP7xhT/pnHq6wtd9wmePG/XxoSSgjrrA2/0xsrJmgQh7u6F7Ii5mNcCGwrlq9rURq1N5S2EKAm2Ef603QSyy/muuAq54MtCTdXCERA4JwKWv9ICzzOlOaybDjGx4MYSwFZgU8LESkJms5UrBiazYUWtyda0TqxYQPieBCFajXb3THYm6bUNKgmahSPkdJohCsMeVLiVGLAOqbbEiq2mY+2ojfM2OAcC50QgTnIK0VVIGjQmS6PaaULHkmc8UrIYrrVZ1iiJmFRZ2LdxGhRAkFRJtnTKksOwsoZOgxDFpLBVjWZbj1qN3ZUCrWghREk/tbXfjFO0BEI0KaRtezgcOIyeH9bslawFToHAWRHIMh0X8KWBE3XS/uhhx/tNS4L2uCRgUmU8AZNS2Wks1RRqKFZq6gQIkXKuUhJXtDle0ZPFQQ1x8UFkqhligRDddVZN+pwQlU1HsuZ0XMjwvXAGBMZCgILTLMaD6Gy3iUu+zzzSlfLCbBpL5/Hk6CQNMsvkIJgcj9VECJFZJjiMvU40z8cGWU+gXGEgiF7vJMQUB9SRM8Sw1+Yf8lhy+g4Z63o9i+jJVMfpTSAQdr5ppuT7pzApeC+cWVvb9wh9ZO2neWomePabCetrMWnDitsXvydAiOEKHf+su93KNUTSN6W+odYketH9sY9cOJDC9XbXlSGGH+nSmJuH+Et0widAyerwDy9UVybiIqooBAJnQUCDU8I+jtMkRE0GOdvINZoXITo20DxJzczvQ6pilePgzidBiE6jyZ5QzBlSnqyeUAwIAIFjEQAh9kTOZuw9u6AZEAACM0MAhNjpsHiR0dwE39kDDYAAEJgnAiDEefoNWgMBIHAGBECIZwAVIoEAEJgnAiDEefoNWgMBIHAGBECIZwAVIoEAEJgnAiDEefoNWgMBIHAGBECIZwB1SiL19tQ+N1HKze3hDUHhFQD8I3u6V11eHTQlI+MDnXyjPb8Sr01DhcXc4UwPdMaPKWyTcvE6VbvLm2oL25TedmNdvJrbvROqPN9triX1G7O7sLJuBCFaNG7umO7jTzeTu8e3y4baRxcq910agWUZVyk1WvUwk95d1HzKjbiGeZAaTPAZzYFmqiuINQyDsJnaYBZHZD5bUVLYee1YrC5IiI+b1f02PDi83j6mb37lt3lEzwWiTU/4KZH4XLesDNreCOnhcrPYMsoGRALcnspwab1lZUqOmUyZJzU7K4oqUgO1q/h2qWJhUdgFC4ebWQgP/8Cvh+KCtrQMNdBMI4lCXabJE734huedaTT1w9t7QSzxC73VhoicJp7mI8NeEBvkpMRHJ7kNFzrWCCh6uvyCWDcrTBgZ4TQ6E2hR8oQKFWF5KpzfElrUMuAWZ0vRzCnShLyIKFqUFsUWM4Nb48JMixs/FWuxymQWsbp8odWw20yjn+0YHsmfIyGG2LutF8TyG3s4y/B+YgdyrU/QuJa+3VylOUzRT4Wa3YQXMZhT2715bOa5J0EmPqXd9IR5y3xrir9eSUQ40BwvRTz/q0oRAvQpoKeuqfa+SsUwM8N6bD2bXj1nN1yuzVVsKgw6zEwRYEI6lFEwy6fgZek4rQOa4LJ6hZCWnDdUkUlK9EdidTgcLrtlDhrzvIpKB9jFpOCpOGnJkWqh8Q4TqykKhGgbG45zzfQk0QSHBkeGdHQ7C1qQE5VkzKsCJ3iU5RG8eFQ11TiLtOh4360KVRHXqBhmJodf0tScJjlhH8MvELyGPZUxh5nJQqiX8yNXpD+eUVr5TJPJHGazPjuNaurcPA4rkjIBQgxLlvhMA7Ros3l5tfOVYhGKs1PXlE4oBRACFRKkmsQa/s3Yjj1F1YbUqRWQ2iYlNCtQUVMPWrYg2QSq2Pt6hcPMzDImjTdrgFsObcUVj4eZGRXNnJhr7yI/r5zWeaZqmRwkwo/BKto7EULkLQzNSZnDRPNmPrODqlhI4wwO7mi+zfSmxnaHGKhwt11zzlijYCNtsoch0UvY5nMjrEO6KpSuReh1WGrMPpqetcPMtLbYY7GrWCi11zsYZibp2ZYepr+iIRvP69nVb2Q7qe2x9rYR3oaV9igcTYAQh74gtkyIyf1pC9zpZgr69MleEJt+f3ASImlyh/oepADwtYtCZATNJSOOKkUEfKE2dneoBfMdINe2qjG+au4tSm8CzgrDuptA4b/UrhImvItUJTOLSt502yBGTCUUsw1uNsnvtBE2OVP88YAnpsdELfXl7aZdkBDbFZlybUbBfms5ZcWhGxAAAoMQACF2w0VLjVlkigtvtxS0AAJAYPIIgBD7uMhvmQ059umMNkAACMwFARDiXDwFPYEAEDg7AiDEs0OMAYAAEJgLAiDEuXgKegIBIHB2BECIZ4cYAwABIDAXBM5IiPE+oB7Pdcj95aOBVn78YDTxEAQEgMBtIjBtQqTbTc0TI71dAEIUqPT21D5I2vvVH1mG3sbc9Q4h7nH570FmtjaOdxRM9LGcVs1z1MuN5+DN3BI51/hkB2mJeRg3tC+bL6IqB2ckxMqIzeJ6hghCbKI1qMTcQ97j9knzpBchzzGnIxJZFB6m1AZXOhpkpmlMc8bfREUl95tNwfYrmWaHNZp3e9M0bpoZpE7Vm9Zke0wWNWNSWxAm8jyVMb8bK5XR7+UOjYSLoOS9cOl5mvAQZfZoVBhUG5vaQIjxlbH6Dp+sZajoeMoqru3pOZ7OeWsWEEbZgEja2lO7ENEIx+StBvbLHPqIL3OcapJNm4bTqWWxUEVc52iQmb6xeSkn6Z4gqq/Q1zEwjuo17/Cmb5yZyVZM0pusXP49pRfEhmXT/qUKgjsQosXd5BfJmDywlMIDv3hKjRTjhVCzBvUYnrJzWIX3mbd4QWwecIfMy9lpaJ47tCHjKgVWq7SOcmg19ZHQjVX2VILZCmxKuFaJ1eoUM0V/K1AKp3oQqGAyL4ilt/8TIfKSwlD6tyQ1phA3SyBbspPgiy9l4BxNhwh9SoS4u5fk1PT1LVnPft41fY0JZkWiBqKhtaKf/Ku1ivgT1OEdf+K+ikLWTDrWDQjBEj+yJanIuEbxMDPJFt4mR7sSe+oT61ncXsOmwpgjmWn/INcUvVmwnIooDZLLNSGkRflQReHJbg3vZ1lvn3pHvhmz3zXERHy7zf1mQ3rw6zNFlTRddAqFIbLAMmbYuefzecdl1CzLEJORMmC6rOBbOiHGWnOYyeFRRI7jeiLBtAc3+amRNs3DLI8gk+upE5mgxLfe7h7WzcsOlk0mY/NQM9X164cd/YURuhRjY9UeT8ZK0pA+7MFObxbNdOZM0ptOQz3R5SqUZaexnc7NoVjpOP0IMTLg42b98Ex//0TIoqiWCs8Di3a1/DGTzTVzXCb0pDIrceBbOiHaV4/cdVbXN8lf4gtiFR468pk41zmsuPDK3+SyWrtUmBkAAAJTSURBVDh1qVZf2k2C3CXkMvVjmJlpOkVvZiryaaZqmXmESY7HagAhbh822ydKIjb3aQcdXx1oYpG1T9+iXzjPTNK2rpnnMmJ6XhJTh5DFcELnhKSWMc2pa0V9zAVHws7+SLLcF8QqmBYfU+pwc+XXPQkeT9c08qyHos5upqymhegK1S4gbYfrHo9tZtXL1zWzMrrlOHusza3r27DSHoWjnoQYWCNu0UOEGbpJ2WnM/PRyDGeC4TsFq80QzRUBF3+eEO0LIOUqntnZ2ViX/fv9zud3BbPTe0ODcnhBLAOkrjT+9WjLhRvuM5HvMAFSrLm/sdkkRIkTvS6cGeECMqu77unpZqqEyaXAndCW4lO9mS97aqleW+wcot9tN91i+rTIMkQ6VY7rI+BqbbL8XC9VXE0jDAwEgMA5EOiZIY4xtOeRwN/Nne8YA40tg1Q1i4y7/jj2WJAHBIDAFRG4ICHGK1C6lZ4HGwbfxOuMrLohxyt6DkMDASAwOgIXJcTRtYdAIAAEgMCICIAQRwQTooAAEJg3AiDEefsP2gMBIDAiAiDEEcGEKCAABOaNAAhx3v6D9kAACIyIAAhxRDAhCggAgXkjAEKct/+gPRAAAiMiAEIcEUyIAgJAYN4IgBDn7T9oDwSAwIgIgBBHBBOigAAQmDcCIMR5+w/aAwEgMCICIMQRwYQoIAAE5o0ACHHe/oP2QAAIjIgACHFEMCEKCACBeSMAQpy3/6A9EAACIyIAQhwRTIgCAkBg3giAEOftP2gPBIDAiAiAEEcEE6KAABCYNwL/D5t/sCdu6I9cAAAAAElFTkSuQmCC)
"""

#Classificando uma frase
import pickle

with open('text_classifier.pkl', 'wb') as f:
  pickle.dump([naive_bayes, onehotencoder, vectorizer], f)

with open('text_classifier.pkl', 'rb') as f:
  bayes, onehot, vec = pickle.load(f)

bayes

onehot

vec

negative.head()

#Pegando um review qualquer para testar um review a ser categorizado
negative_text = negative.iloc[0:1, [2,3]]
negative_text

X_cat = negative_text[['variation']]
X_cat

X_cat = onehot.transform(X_cat).toarray()
X_cat = pd.DataFrame(X_cat)
X_cat

negative_text

#Para dizer que os índices são iguais
X_cat.index = negative_text.index
X_cat.index, negative_text.index

negative_df = pd.concat([negative_text, X_cat], axis = 1)
negative_df

#Agora apagando o variation
negative_df.drop(['variation'], axis = 1, inplace = True)
negative_df

#Processando o review
negative_coutvectorizer = vec.transform(negative_df['verified_reviews'])

#Visualizar
negative_coutvectorizer

review = pd.DataFrame(negative_coutvectorizer.toarray())
review

negative_df.drop(['verified_reviews'], axis = 1, inplace = True)
negative_df

negative_df.index = review.index

negative_final = pd.concat([negative_df, review], axis = 1)
negative_final

#Verificar se qualifica corretamente como review negativo (valor 0)
bayes.predict(negative_final)

#Probabilidade de estar certo
bayes.predict_proba(negative_final)